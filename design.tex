\section{Design of BigSim}
\label{Sec:Design}

We have sketched the process of how to replace a OpenFlow-switch-connected network
with a single OpenFlow switch in section~\ref{Sec:MotivationalExample}.
The overview architecture of our design is shown in Figure~\ref{Fig:BigSimOverview}.
Taking a snapshot of SDN network $SN$ as input, BigSim transform it to a single ``big"
OpenFlow switch $BS$ that preserve the forwarding logic of the original network.
In this section, we elaborate the details and relevant algorithms
in each procedure.

\subsection{Finding Minimal Set of ECs}
By aggregating and slicing forwarding rules in a SDN network to ECs,
one can obtain a compact representation of all the classes of network flows.
\begin{definition}
Equivalence Class (EC) is the set of packets that
experience identical forwarding action at \textbf{any} network device.
\label{Def:EC}
\end{definition}

Inspired by VeriFlow\cite{Veriflow}, we aggregate forwarding rules using a trie.
A trie node have three child nodes, each representing one of the three possible
bit values a rule can match: zero, one or wildcard.
The entire tree is composited by several sub-tries,
each representing one packet header field.
In the tree-topology network, for example, the trie is just a single sub-trie that
corresponds to the $NW\_DST$ header field (network-layer destination address)
of the rule match field.
Notice that EC can be defined by multiple fields together.
As a result, we can, for example, match the source address of the packet (e.g. $NW\_SRC$)
and service type of the traffic ($TCP\_SRC$).
The resulting trie will then be three sub-tries concatenated.
Here we give solutions to two problems that VeriFlow neglected.

\subsubsection{Disjoint EC as Disjoint Intervals}
By traversing from root node to a leaf node, we can obtain a set of packets
that a rule matches.
All the leaves thus contains all the packet header values in the network,
paired as a series of ranges, as $A, B$ and $C$ in Figure~\ref{Fig:DisjointECsAsInterval}.
These header value ranges are not independent and may overlapping with each other.
Finding the set of disjoint ECs requires us to splitting this list of ranges $R$ to
a list of non-overlapping intervals,
as the set of ECs shown at the top of Figure~\ref{Fig:DisjointECsAsInterval}.
Not algorithmic described in\cite{Veriflow},
we show this task can be accomplished in $O(N \times M\log M)$ time,
where $M=|R|$ is the number of intervals and $N$ is the number of header bits,
as follows\cite{SplitDisjointInterval}.

First we unzip $R$ into an array $A$ of $2M$ values,
each flagged as either a start $S$ or an end $E$ of a range.
\footnote{Equal values with same flag are reduced to an single element.}
Before iterating $A$, we sort it, breaking the tie by putting $S$ point before $E$ point.
Then we maintain the difference $d$ between the number of $S$ points and the number of $E$ points
seen so far, while visit each point in sorted order:
\begin{itemize}
\item If current element $x$ is $S$ and $d > 0$,
        we end the previous interval with ending value $x - 1$.
        start a new interval with starting value $x$
        (line~\ref{Alg:LineEndStart1}-\ref{Alg:LineEndStart2}).
\item If current element $x$ is $E$, we end the previous interval with ending value $x$.
        (line~\ref{Alg:LineEndEnd}).
\item In either case, we update the potential new interval's start value \textit{prev}
        (line~\ref{Alg:LineNewPrev1} and \ref{Alg:LineNewPrev2}).
\end{itemize}

Updating forwarding rules in the network will result in the change of EC set.
By maintaining the rules in a trie, we can efficiently update ECs
incrementally as follows.
Inserting new rule to the trie require us to do a depth-first-style trie traverse.
This process automatically narrows down the affected rules by ignore the branches
that is impossible to overlap with the newly inserted rule.
The result of the procedure is the set of the effected ranges.
We only need to run Algorithm~\ref{Alg:GenDisjointECs} to update ECs in the effected ranges.

\begin{figure}[t]
\centering
\includegraphics[scale=.52]{figures/DisjointECs.pdf}
\caption{A class of packets are abstracted as a range of packet header values.
        Five equivalence classes can be obtained via splitting three ranges A, B and C.
        The rules that intersect with each EC is also shown at the bottom.}
\label{Fig:DisjointECsAsInterval}
\end{figure}

\begin{algorithm}[t]
\DontPrintSemicolon
\KwData{$R = $ set of rules from the leaf-node of the trie}
\KwResult{$EC = $ set of equivalence classes as disjoint intervals}
$cnt \gets 0$\;
$S = $ \{start points of $\forall r \in R\}$, $E = $ \{end points of $\forall r \in R\}$\;
$A \gets Sort(S \bigcup E)$ in non-decreasing order\;
$EC \gets \emptyset$\;
\ForEach {$x \in A$} {
        \uIf {$x \in S$} {
                \If {$cnt \neq 0$} {\label{Alg:LineEndStart1} 
                        $EC \gets EC \text{ }\bigcup \text{} [prev, x-1]$\;
                }\label{Alg:LineEndStart2} 
                $prev \gets x$\;\label{Alg:LineNewPrev1}
                $cnt \gets cnt + 1$\;
        }
        \Else ($x \in E$) {
                $EC \gets EC \text{ } \bigcup \text{ } [prev, x]$\;\label{Alg:LineEndEnd}
                $prev \gets x + 1$\;\label{Alg:LineNewPrev2}
                $cnt \gets cnt - 1$\;
        }
}
\caption{Generate Disjoint ECs\label{Alg:GenDisjointECs}}
\end{algorithm}

\subsubsection{Minimal EC Set}
The resulting disjoint EC set $ECS$ obtained from Algorithm~\ref{Alg:GenDisjointECs} are unfortunately not the optimal one with minimum size.
Many ECs can be merged together according to the definition of ECs.
For example, $EC_2$ and $EC_4$ in Figure~\ref{Fig:DisjointECsAsInterval} can be merged as one EC, since the packets in both ECs experience the same set of rules throughout the network. It follows that, to generate the correct set of rules on the transformed ``big switch", we only need to model the forwarding behavior of either one of the ECs. In other words, for any two ECs $\alpha$ and $\beta$, we have:
\begin{lemma}
$\forall \alpha, \beta $ if $\alpha$ and $\beta$ are mergeable, then $FG(\alpha) \equiv FG(\beta)$.
\label{Lemma:MergeFG}
\end{lemma}
$FG()$ in Lemma~\ref{Lemma:MergeFG} is a function that maps an EC into a forwarding graph, which will be defined in section \ref{Sec:Generating Forwarding Graphs}. It suggests that operating on the minimal EC set can
reduce running time in the later phase of generating forwarding graph
as well as populating final OpenFlow rules.
Here we provide a solution with its proof.
Our solution builds on the following lemma.
\begin{lemma}
For any pair of disjoint ECs $\alpha$ and $\beta$, they are mergeable
if they intersect with the same set of rules $\Delta$ in the network.
\label{Lemma:MergeEC}
\end{lemma}
According to Lemma~\ref{Lemma:MergeEC}, in Figure~\ref{Fig:DisjointECsAsInterval} for example,
because both $EC_2$ and $EC_4$ intersect with range $B$ and $C$, we can treat them as one EC.

If EC $\alpha$ and EC $\beta$ satiesfis the condition in Lemma~\ref{Lemma:MergeEC},
in Algorithm~\ref{Alg:GenDisjointECs}, $\alpha$ and $\beta$ come from
the same set of rules.
At any network device $d$ in the network, let $\delta \in \Delta$ be the rule on $d$ with
\textbf{highest priority}.
If no such $\delta$ exist, packets from both $\alpha$ and $\beta$ are dropped on $d$.
Otherwise, packets of both $\alpha$ and $\beta$ will match rule $\delta$ and
device $d$ will forward both of them according to the action specified in $\delta$.
Notice that in another device $d'$, the highest priority rule that covers both $\alpha$
and $\beta$ maybe different, e.g. $\delta' \neq \delta$.
However, as long as $\delta$ is always unique at given $d$,
it is sufficient to say the forwarding behavior at $d$ for both $\alpha$ and $\beta$ are identical.
By Definition~\ref{Def:EC},
packets in $\alpha$ and $\beta$ can be treated as one single EC.

Finding the list of rules $\Delta[\alpha]$ that intersects with EC $\alpha$ can be done
efficiently with two data structure,
each taking care one of the two cases\cite{FindIntersectionWiki}:
\begin{itemize}
\item Rule $\delta$ intersects $\alpha$ with its start and/or end point in $\alpha$.
        We can reuse the sorted array $A$ in Algorithm~\ref{Alg:GenDisjointECs}.
        Here we assume we augmented each value in $A$ with a pointer that points to
        the rule it belongs to.
        By doing binary search, we can find the minimum and maximum value in $A$ that
        are in the range of $\alpha$.
        All intervals that intersect with $\alpha$ must be contained between
        the minima and maxima.
        We can then do linear search in this reduced list of ranges $A'$,
        check one by one if the interval that value $a\in A'$ belongs to
        intersects with $\alpha$.
        The total time complexity for both linear and binary search is thus $O(\log M + K)$,
        assuming $K=|\Delta|$ is the number of reported intervals.
\item Rule $\delta$ covers $\alpha$ entirely. We can build
        a central interval tree\cite{ComputationalGeometryBook} using all available ranges.
        We pick a random value $x \in \alpha$ and query the central interval tree for
        all ranges that intersect with $x$, which can be done in $O(\log M + K)$ time,
        at the cost of $O(M log M)$ time for building the central interval tree. 
\end{itemize}

For each EC $\alpha$ we have found the list of intervals $\Delta[\alpha]$
that intersects with it with both interval tree and ordered list of boundary values.
By mapping each rule to an unique binary ID of length $\log_2 M$,
we can encode $\Delta[\alpha]$ to a string $C_\alpha$ of at most length $M\log_2 M$, putting
small binary IDs before large ones.
Then we use a hash table $H$ to group mergeable ECs by hashing each EC $x$ to $C_x$.
The minimal size of ECs is the number of unique keys in $H$.
In the later text, when we say ``iterate through all (disjoint) ECs" or "for each EC" etc,
we are actually visiting the first ECs in each set $H[key]$, $\forall key \in H$.


\subsection{Generating Forwarding Graphs}
\label{Sec:Generating Forwarding Graphs}

In the second stage, we compute forwarding graphs for each EC and
compress them in order to be used in the next stage. A forwarding graph is a directed graph that represents how packets are processed by the network. For a specific set of packets (an EC), a node $u$ in the forwarding graph is a devices that the packets encounter in the network, and there is an edge $(u, v)$ in the graph if device $u$ forward the packets to device $v$ in the network. 
Forwarding graph not only concatenates the forwarding actions of each EC,
but also visualizes the flow the EC.
For a fixed EC $x$, we connect the network devices that have rules for $x$
with directed edges that point to the next hop,
which is determined by the action field of the rule.
Since our goal is to compress the network logic, we are more interested in the sources
and sinks of the directed graph.
Here we discuss two issues that specific to our problem: where to start the
traversal according to our needs and what we can achieve at the end of the traversal.

\subsubsection{Initiate Traversal}
We depict the generalized forwarding graph $FG(x)$ for EC $x$
in Figure~\ref{Fig:ForwardingGraphECX}.
We define \textit{edge switches} as these that connect to network devices
outside $SN$, either a host end or another switch.
In contrast, \textit{internal switches} are these that entirely contained inside
$SN$ and are abstracted away in the final big switch.
Source node $src$ and its out-going edge represent an edge switch $sw$ that
forwards EC $x$ \textbf{coming from} port $p$; it can be described by $(sw, p)$ pair.
Sink node $snk$ represent the end of the forwarding $sw$,
which is also denoted by $(sw, p)$, where $p$ is either the port number
specified by the action field or \texttt{NULL} if there is no rule for $x$ on $sw$.
%We denote the set of source nodes as $SRC(x)$, the set of sink nodes as $SNK(x)$.
Notice that (1) source nodes in $FG(x)$ can only be edge switch,
while it is possible that sink nodes are inner switches;
(2) the inner graph may contain both edge and internal switches.

\begin{figure*}[t]
\centering
\includegraphics[scale=.75]{figures/ForwardingGraph.pdf}
\caption{An illustration of the $FG(x)$ forwarding graph for EC $x$}
\label{Fig:ForwardingGraphECX}
\end{figure*}

We add a super-source node $SRC^x$and a super-sink node $SNK^x$ as
the boundaries of the graph $FG(x)$.
For convenience in discussion, we distinguish two kinds of port on \textbf{edge switch}es:
\begin{itemize}
\item \textit{end port} connects to endpoints or the outside of the network we are abstracting
\item \textit{inner port} connects to another network device inside the network we are abstracting.
\end{itemize}
We add an edge from $SRC^x$ to a source node(edge switch) $src$ if
\begin{enumerate}
\item $src.sw$ has a forwarding rule $r$ that covers EC $x$;
\item the $IN\_PORT$ field of rule $r$ on $src.sw$ is an \textbf{end port}.
\end{enumerate}
otherwise, we don't need to initiate traverse at all
(see line~\ref{Alg:LineStartDFS1} to~\ref{Alg:LineStartDFS2}
in Algorithm~\ref{Alg:GenForwardingGraph}).
Correspondingly, we add an edge from a sink node $snk$ to super sink $SNK^x$
if both conditions are satisfied:
\begin{enumerate}
\item the $snk.sw$ is an edge switch in the network;
\item the $OUT\_PORT$ field determined by the rule's action on $snk.sw$
        is \textbf{end port}
\end{enumerate}
Forwarding graphs are generated by starting from source nodes that connected to $SRC^x$
and traversing in the depth-first-search style by following the action of
the highest-priority rule covering EC $x$.

\subsubsection{At the Finishing of the Traversal}
At the end of the depth-first-search algorithm shown in
Algorithm~\ref{Alg:GenForwardingGraph}, we can discover three kinds of
``path" in $FG(x)$ that related to rule generation on the big virtual switch:
\begin{itemize}
\item \textbf{Forwarding Path}(line~\ref{Alg:LineForwardPath1}-\ref{Alg:LineForwardPath2}).
        The path, starting from super source,
        leads to super sink node through a end port on another edge switch to host.
        This is a normal forwarding path for packets $\in$ EC $x$.
\item \textbf{Dropped in the Middle}(line~\ref{Alg:LineDropPath1}-\ref{Alg:LineDropPath2}).
        The path ends inside the graph, unable to arrive
        at the super sink node. This path tell us that packets
        defined by EC $x$ are dropped, at least partially,
        in some intermediate switch in the network.
\item \textbf{Forwarding Loop}(line~\ref{Alg:LineLoopPath}).
        There is a directed cycle in the graph.
        This behavior can be emulated in the semantic of \textbf{performance equivalence},
        but not by \textbf{logical equivalence} studied in this paper.        
        For example, we can emulate a forwarding loop in the network by
        (1) recording the volume of the looping packets;
        (2) increasing the delay of other packets on the basis of the amount of looping packets
        (3) adding a rule so that looping packets are dropped by big switch;
\end{itemize}

\begin{algorithm}[t]
\DontPrintSemicolon
\KwIn{$nodes = $ Switches that have rule for $x$ \newline
        Topology of the network $topo$}
\KwResult{Forwarding graph $FG(x)$ for EC $x$}
\SetKwProg{Fn}{Function}{}{\KwRet}
\SetKwFunction{Traverse}{traverse}
\SetKwFunction{GenRule}{generate\_rules}
\Fn{\Traverse{$curr$, $src$, $snk$}} {
        \uIf {$curr$ \upshape is \textbf{NOT} visited} {
                $r \gets$ \textbf{highest-priority} rule on $curr$ that covers $x$\;
                \If {r \upshape is NULL or $r.action$ is DROP} {\label{Alg:LineDropPath1}
                        $snk \gets$ ($curr$, NULL)\;
                        \GenRule{$x, src, snk$}\;
                        \KwRet\;
                }\label{Alg:LineDropPath2}
                $next \gets topo[curr][r.action.outport]$\;
                \If {next $\not\in$ nodes} {\label{Alg:LineForwardPath1}
                        $snk \gets$ ($curr$, $r.action.outport$)\;
                        \GenRule{$x, curr, src, snk$}\;
                        \KwRet\;
                }\label{Alg:LineForwardPath2}
                mark $curr$ as visited\;
                \Traverse{$next, src, snk$}\;
        }
        \Else {
                report forwarding loop\;\label{Alg:LineLoopPath}
        }
}\;
\ForEach{$n \in$ \upshape neighbors of $SRC^x$} {\label{Alg:LineStartDFS1}
        \If {\upshape $n$ is \textbf{NOT} visited} {
                $inport \gets$ inport number from $SRC^x$ to $n$\;
                \Traverse{$n$, $src=$\upshape($n$, $inport$), $snk=$NULL}\;
        }
}\label{Alg:LineStartDFS2}
\caption{Generate Forwarding Graph for EC $x$\label{Alg:GenForwardingGraph}}
\end{algorithm}


\subsection{Populating Flow Table on Big Switch}
Depending on the kind of path, we can easily generate OpenFlow rules on the abstracted
big switch at the end of forwarding graph traversal by calling \texttt{generate\_rules},
as described in Algorithm~\ref{Alg:GenAllRules}.
We maintain a hash table $PortMap$ to map end ports on edge switches to the big virtual switch.
This table is configured as rule generation using $global\_port$ variable.
Algorithm~\ref{Alg:GenAllRules} fills the mandatory fields in an OpenFlow rule:
\begin{itemize}
\item The $MATCH$ field is given by the EC $x$ itself, e.g. the range of matching packets header
        (line \ref{Alg:LineMatch})
\item The $IN\_PORT$ field is the mapped port number of $src.port$ (line~\ref{Alg:LineInport})
\item Depending on the $dst$'s port, we generate either a drop action
        (line~\ref{Alg:LineGenDropRule})
        or a forward action with appropriate mapped port number of $dst.port$ 
        (line~\ref{Alg:LineGenForwardRule1}-\ref{Alg:LineGenForwardRule2})
\end{itemize}

\begin{algorithm}[t]
\DontPrintSemicolon
\KwData{$PortMap$ maps $port$ on $sw$ $\rightarrow port$ on big switch\newline
        $global\_port$ assigned to unseen port number}
\KwResult{New rule $r$ to install in $BS$}
Assume $global\_port$ is globally initialized to 0\;
\SetKwProg{Fn}{Function}{}{\KwRet}
\SetKwFunction{GenRule}{generate\_rules}
\Fn{\GenRule{$x, src, dst$}} {
        $r.match \gets x$\;\label{Alg:LineMatch}
        \If {src.port $\not\in$ PortMap[src.sw]} {
                $PortMap[src.sw][src.port] \gets global\_port++$\;
        }
        $r.inport = PortMap[src.sw][src.port]$\;\label{Alg:LineInport}
        \uIf {dst.port \upshape is NULL} {
                $r.action \gets $ drop\_action\;\label{Alg:LineGenDropRule}
        }
        \Else {
                \If {dst.port $\not\in$ PortMap[dst.sw]} {\label{Alg:LineGenForwardRule1}
                        $PortMap[dst.sw][dst.port] \gets global\_port++$\;
                }
                $r.action \gets $ forward\_action\;
                $r.action.outport \gets PortMap[dst.sw][dst.port]$\;\label{Alg:LineGenForwardRule2}
                
        }
}
\caption{Generate Rule for EC $x$ on Big Switch\label{Alg:GenAllRules}}
\end{algorithm}



