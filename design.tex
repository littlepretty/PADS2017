\section{Design of BigSim}

We have sketched the process of how to replace a OpenFlow-switch-connected network
with a single OpenFlow switch in section~\ref{Sec:MotivationalExample}.
In this section, we elaborate the details and relevant algorithms
in each procedure.

\subsection{Finding Minimal Set of ECs}

By aggregating and slicing forwarding rules in a SDN network to ECs,
one can obtain a compact representation of all the classes of network flows.
\begin{definition}
Equivalence Class (EC) is the set of packets that
experience identical forwarding action at \textbf{any} network device.
\end{definition}
Inspired by VeriFlow\cite{Veriflow}, we aggregate forwarding rules using a trie
compositing by several sub-tries, each representing one header field.
In the tree-topology network, for example, the trie is just a single sub-trie that
corresponds to the packet header (network-layer destination address)
part of the rule match field.


\subsubsection{Disjoint EC as Disjoint Intervals}
By traversing from root node to a leaf node, we can obtain one set of packets
that a rule matches.
All the leaves thus contains all the rules in the network.
However, these rules are not independent and may overlapping with each other.
In essential, each rule is an range of packet header values;
the set of rules are thus a list of ranges $R$ where $\forall r \in R$ can be
described by a pair of starting header value and ending header value.
Finding the set of disjoint ECs requires us to splitting $R$ to
a list of non-overlapping intervals.
Not algorithmic described in\cite{Veriflow},
we show this task can be accomplished in $O(N \times M\log M)$ time,
where $M=|R|$ is the number of intervals and $N$ is the total number of header bits,
as follows\cite{SplitDisjointInterval}.

First we unzip $R$ into an array $A$ of $2M$ values,
each flagged as either a start $S$ or an end $E$ of a range.
\footnote{Equal values with same flag are reduced to an single element.}
Before iterating $A$, we sort it, breaking the tie by putting $S$ point before $E$ point.
Then we maintain the difference $d$ between the number of $S$ points and the number of $E$ points
seen so far, while visit each point in sorted order:
\begin{itemize}
\item If current element $x$ is $S$
        \begin{itemize}
                \item If $d > 0$, we end the previous interval with ending value $x - 1$
                        and start a new interval with starting value $x$
                \item If $d = 0$, we start a new interval with starting value $x$
        \end{itemize}
\item If current element $x$ is $E$, we end the previous interval with ending value $x$.
        If the next element is also a $E$ point, we start a new interval with starting value
        $x + 1$.
\end{itemize}

Updating forwarding rules in the network will result in the change of EC set.
By maintaining the rules in a trie, we can efficiently update ECs incrementally as follows.
Inserting new rule to the trie require us to do a depth-first-style trie traverse.
This process automatically narrows down the affected rules by ignore the branches
that is impossible to overlap with the newly inserted rule.
The result of the procedure is the set of the effected ranges.
We only need to run Algorithm~\ref{Alg:GenDisjointECs} to update ECs in the effected ranges.

\begin{algorithm}[h]
\DontPrintSemicolon
\KwData{$R = $ set of rules from the leaf-node of the trie}
\KwResult{$EC = $ set of equivalence classes as disjoint intervals}
$cnt \gets 0$\;
$S = $ \{start points of $\forall r \in R\}$, $E = $ \{end points of $\forall r \in R\}$\;
$A \gets Sort(S \bigcup E)$ in non-decreasing order\;
$EC \gets \emptyset$\;
\ForEach {$x \in A$} {
        \uIf {$x \in S$} {
                \If {$cnt \neq 0$} {
                        $EC \gets EC \bigcup [prev, x-1]$\;
                }
                $prev \gets x$\;
                $cnt \gets cnt + 1$\;
        }
        \Else ($x \in E$) {
                $EC \gets EC \bigcup [prev, x]$\;
                $prev \gets x + 1$\;
                $cnt \gets cnt - 1$\;
        }
}
\caption{Generate Disjoint ECs\label{Alg:GenDisjointECs}}
\end{algorithm}

\subsubsection{Minimal EC Set}
The resulting disjoint EC set $ECS$ obtained from Algorithm~\ref{Alg:GenDisjointECs} are unfortunately not the optimal one with minimum size.
Many ECs can be merged together.
For example, EC1 and EC3 in section~\ref{Sec:MotivationalExample} can be seen as one EC.
By the definition of EC, since $\forall d$ takes identical forwarding action for any one of
the mergeable ECs, we have:
\begin{lemma}
A set of mergeable disjoint ECs has the same forwarding graph.
\label{Lemma:MergeFG}
\end{lemma}
Thus, operating on the minimal EC set can reduce running time in the later phase of
generating forwarding graph as well as populating final OpenFlow rules.
Here we provide a solution with its proof.
Our solution builds on the following Lemma.
\begin{lemma}
A pair of disjoint ECs in $ECS$ is mergeable if they intersect with
the same set of rules in the network.
\label{Lemma:MergeEC}
\end{lemma}
The proof of Lemma~\ref{Lemma:MergeEC} is as follows.
Let $\alpha$ and $\beta$ be two ECs that intersect with the same set of rules $\Delta$.
At $\forall$ network device $d$, let $\delta \in \Delta$ be the rule on $d$ with
highest priority.
If no such $\delta$ exist, packets from both $\alpha$ and $\beta$ are dropped on $d$.
Otherwise, device $d$ will forward packets from both $\alpha$ and $\beta$ according to the same
rule $\delta$.
By the definition of EC, packets in $\alpha$ and $\beta$ can be merged as one single EC
since at any network switch they have identical forwarding action.

Finding the list of rules $\Delta[\alpha]$ that intersects with EC $\alpha$ can be done
efficiently with two data structure,
each taking care one of the two cases\cite{FindIntersectionWiki}:
\begin{itemize}
\item Rule $\delta$ intersects $\alpha$ with its start and/or end point in $\alpha$.
        We can reuse the sorted array $A$ in Algorithm~\ref{Alg:GenDisjointECs}.
        Here we assume we augmented each value in $A$ with a pointer that points to
        the rule it belongs to.
        By doing binary search, we can find the minimum and maximum value in $A$ that
        are in the range of $\alpha$.
        All intervals that intersect with $\alpha$ must be contained between
        the minima and maxima.
        We can then do linear search in this reduced list of ranges $A'$,
        check one by one if the interval that value $a\in A'$ belongs to
        intersects with $\alpha$.
        The total time complexity for both linear and binary search is thus $O(\log M + K)$,
        assuming $K=|\Delta|$ is the number of reported intervals.
\item Rule $\delta$ covers $\alpha$ entirely. We can build
        a central interval tree\cite{ComputationalGeometryBook} using all available ranges.
        We pick a random value $x \in \alpha$ and query the central interval tree for
        all ranges that intersect with $x$, which can be done in $O(\log M + K)$ time,
        at the cost of $O(M log M)$ time for building the central interval tree. 
\end{itemize}

For each EC $\alpha$ we have found the list of intervals $\Delta[\alpha]$
that intersects with it with both interval tree and ordered list of boundary values.
By mapping each rule to an unique binary ID of length $\log_2 M$,
we can encode $\Delta[\alpha]$ to a string $C_\alpha$ of at most length $M\log_2 M$, putting
small binary IDs before large ones.
Then we use a hash table $H$ to group mergeable ECs by hashing each EC $x$ to $C_x$.
The minimal size of ECs is the number of unique keys in $H$.
In the later text, when we say ``iterate through all (disjoint) ECs" or "for each EC" etc,
we are actually visiting the first ECs in each set $H[key]$, $\forall key \in H$.


\subsection{Generating Forwarding Graphs}
In the second stage, we compute forwarding graphs for each EC and compress them to be used in
the next stage.
Considering a fixed EC $x$, we can connect the network devices that have rules for $x$
with directed edges that point to the next hop, which is available in the rule action field.
This forwarding graph $FG(x)$ efficiently concatenates the forwarding actions for each EC
in the network.
Since our goal is to compress the network logic, we are more interested in the sources
and sinks of the directed graph.
We define \textbf{Edge switches} are these switches whose port will be remapped to the port on
the resulting big switch;
in contrast, \textbf{internal switches} are abstracted away in the final big switch.
Both of them are corresponding to ports on the edge switches.
Therefore forwarding graphs can be generated by starting from any edge switch and traversing
by following the action of the rule determined by EC $x$.

We depict the generalized forwarding graph $FG(x)$ for EC $x$
in Figure~\ref{Fig:SummaryForwardingGraph}.
We make all the edge switches to be both the possible
(if there is a link to/from the inner graph) source and sink nodes.
The inner graph between sink and source may contain both edge and internal switches.
We consider three kind of ``path" in $FG(x)$:
\begin{itemize}
\item \textbf{Forwarding Path}. The path leads to the outside of the graph, e.g.
        another edge switch's port to host.
        This is a normal forwarding path for one kind of packets.
\item \textbf{Dropped in the Middle}. The path ends inside the graph. The packet defined
        by EC $x$ are dropped in some intermediate switch in the network.
\item \textbf{Loop}. There is a directed cycle in the graph. This behavior can be
        emulated in the semantic of \textbf{performance equivalence}, but not by
        \textbf{logical equivalence} studied in this paper.
\end{itemize}


\subsection{Populating Flow Table on Big Switch}




