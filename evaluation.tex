\section{Evaluation}
We show that given an interested SDN (sub)network with rules $SN(R)$, our approach can 
(1) transform $SN(R)$ to a single OpenFlow switch without any loss of forwarding logic in network $SN(R)$;
(2) save emulation resources such as number of total rules in the network and emulation runtime.

In this section, we consider a tree topology with two topological parameters: depth $d$ and fanout $f$.
Such a tree network $tree(d, f)$ can connect $f^d$ hosts with $\frac{f^d - 1}{f-1}$ switches in total.
Though not known as a scalable network architecture
(a good scalable alternative will be fat-tree topology),
it is good for demonstrational purpose since the tree topology is well-structured and
all hosts in it are potentially fully-connected with at most $2d$ hops.

\subsection{Preserve Forwarding Logic}
We generate forwarding logic in tree-topology network by create paths between random host pairs.
One can find the shortest path between a pair of hosts $(s, d)$ with
a layer-two learning switch controller application.
Traversing the tree up and down in breadth-first-search style, learning switch application
can automatically install OpenFlow rules on each hop once we initiate \texttt{ping} between
the given pair of host.
More specifically, we start a tree-topology network $net_1$ in Mininet\cite{Mininet},
connecting all switches to a l2\_learning\cite{Pox} switch controller.
For any network host $s$, we randomly generate a list of distinct hosts $dsts$,
then let $s$ \texttt{ping} each host $d \in dsts$.
After doing this \texttt{ping} process for all hosts, we take a snapshot of this network by
\begin{enumerate}
\item Recording the network topology, e.g. host to switch and switch to switch connections.
\item Logging all rules on all switches with \texttt{ovs-ofctl dump-flows} commands
\end{enumerate}
We then feed the above information as input and generate the rules of the new big switch
and port mapping according to procedures and algorithms presented in section~\ref{Sec:Design}.
Now we create another emulated network using Mininet.
This big-switch network $net_2$ has one OpenFlow switch that connects to $f^d$ hosts using
appropriate port number deducted from both the $PortMap$ from Algorithm~\ref{Alg:GenAllRules}
and link information in $net_1$'s topology record.
Moreover, rules generated by Algorithm~\ref{Alg:GenAllRules} are installed on the single
switch by \texttt{ovs-ofctl add-flow} commands.

To proof that our approach can preserve the existing forwarding logic,
we generate a matrix $\mathcal{M}$ of size $f^d$ by $f^d$, each element randomly picked
from integer range [1, 10].
In both $net_1$ and $net_2$, host $i$ will send $\mathcal{M}[i][j]$ packets to host $j$
using \texttt{ping}, if $i \neq j$.
To prevent l2\_learning switch controller from installing new rules in $net_1$, we take it down
in this stage.
The result of this experiment is a matrix $\mathcal{R}_k$ where $\mathcal{R}[i][j]$ denote
the number of received \texttt{ping} packets between host $i$ and host $j$ in $net_k$.

We have repeated this experiment for different ($f, d$) pairs $\in$
\{(2, 2), (2, 4), (3, 2), (3, 4), (4, 2), (4, 4)\} and found that $\mathcal{R}_1 = \mathcal{R}_2$
holds in all six experiment settings.
As an example, we have visualized $\mathcal{R}_1$ and $\mathcal{R}_2$ for ($f=3, d=2$) as gray image
in Figure~\ref{Fig:PingMatrix1} and Figure~\ref{Fig:PingMatrix2},
where brightness is proportional to number of received packets.
In this way it is easy to see that $\mathcal{R}_1$ and $\mathcal{R}_2$ are identical.

\begin{figure*}[t]
        \centering
        \subfloat[Packets received in $net_1$] {
                \includegraphics[scale=.5]{figures/ping_mat_2_3.eps}
                \label{Fig:PingMatrix1}
        }
        \subfloat[Packets received in $net_2$] {
                \includegraphics[scale=.5]{figures/bs_ping_mat_2_3.eps}
                \label{Fig:PingMatrix2}
        }
        \caption{$\mathcal{R}_1$ and $\mathcal{R}_2$ of two emulated networks ($f=3, d=2$)}
        \label{Fig:TwoPingMatrix}
\end{figure*}

